# 深入理解java虚拟机：java高级特性和最佳实践

参考《Java程序性能优化-让你的Java程序更快、更稳定》(葛一宁等编著)中有关虚拟机部分的例子 
## 第二章：知识点

### 一、java虚拟机运行时数据区 

#### 1.程序计数器：

- 每一个线程都需要有独立的程序计数器，用来记录当前线程下一条运行的指令。<br/>
- 如果当前线程正在执行的是java方法，那么程序计数器记录的就是java字节码地址，如果是native方法，则计数器为空。<br/>
- 此区域是唯一一个在java虚拟机规范中没有规定任何outofmemoryerror情况的区域。  

#### 2.java虚拟机栈

- 线程私有，生命周期和线程一样<br/>
- java虚拟机栈是描述java方法执行的内存模型：每个方法被执行的同时会创建一个栈帧，用来存储局部变量表，操作栈，动态链接，方法出口等，每一个方法执行的过程就对应着一个栈帧在虚拟机栈中入栈和出栈的过程<br/>
- 局部变量表可以存放java的基本数据类型和对象引用、returnAddress类型（一条字节码指令地址）。在编译期间就已经完成分配了局部变量表的空间。通过Xss进行虚拟机栈空间进行分配<br/>
- 如果线程请求的栈深度大于了虚拟机栈所允许的深度，将抛出stackoverflowerror的异常。如果虚拟机允许动态扩展，当扩展时无法申请到足够的内存就会抛出outofmemoryerror的异常。

#### 3.本地方法栈
- 和虚拟机栈类似，只不过虚拟机栈执行的是java方法（字节码）服务，而本地方法栈使用的是native方法服务。也会存在那两种异常<br/>

#### 4.java堆
- 所有线程所共享，虚拟机启动的时候创建，唯一目的是用来存放对象实例。分为新生代和老年代，新生代分为Eden空间，from survivor空间和to survivor空间<br/>
- 可通过Xms和Xmx进行控制，如果堆中没有内存进行分配对象实例就会报outofmemoryerror的异常。

#### 5.方法区
- 所有线程共享，用来存储已经被虚拟机加载的类的类型信息，常量池，域信息，方法信息。类型信息包括类的完整名称，父类的完整名称，类型修饰符（public/protected/private）和类型的直接接口类表；常量池包括这个类方法，域等信息所引用的常量信息；域信息包括域名称，域类型和域修饰符；方法信息包括方法名称，返回类型，方法参数，方法修饰符，方法字节码，操作数栈和方法帧栈的局部变量区大小以及异常表。

### 二、对象访问
#### 1.句柄访问：
- 使用句柄访问会在java堆中划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据的各自地址信息。
![图示](https://github.com/myismyself/book_tip_jvm/blob/master/1525444405(1).png)
#### 2.直接指针访问的方式
- reference中存储的就是对象的地址值
![图示](https://github.com/myismyself/book_tip_jvm/blob/master/1525444442(1).jpg)
### 三、实战outofmemoryerror

### 四、jvm的内存分配参数
- Xmx 设置可以分配堆的最大内存     Runtime.getRuntime().maxMemory()：用来获得系统可用的最大的堆内存。
- Xms 设置系统可用的最小堆空间，也就是系统启动时jvm所占据的系统内存大小。
![xms设置的相关影响](https://github.com/myismyself/book_tip_jvm/blob/master/Xms.jpg)
因此 将Xmx和Xms设置的相同可以减少系统初期gc的运行次数 减少对系统的初期对性能的影响。
- Xmn 设置新生代的大小，设置新生代的大较大会减小老年代的大小，参数对系统性能和gc有很大的影响 一般设置为Java堆的4/1到3/1。hot spot虚拟机中XX:NewSize表示设置新生代的初始大小 ，XX:MaxNewSize表示设置新生代的最大值 这两个值设置的不一样也会影响系统的开销。通常情况下 设置Xmn就能满足需求
- 在hot spot虚拟机中 XX:PermSize设置方法区的初始大小，XX:MaxPermSize设置方法去的最大值。方法区的大小决定了系统可以定义多少个类和多少常量。
- Xss用来设置虚拟机栈的大小（为每个线程执行方法时开辟的空间大小）。 函数运行时，都需要在栈中开辟空间，如果栈分配的空间太小，那么线程运行时就没有足够的空间来分配局部变量，或者打不到足够函数调用的深度，导致程序异常退出，如果太大，那么开设线程的内存成本就会上升，支持的线程数就会减小。
- -XX:SurvivorRatio用来设置新生代中eden空间和from空间的比例关系，注意from空间和to空间的大小是相同的。因此加入设置Xmn大小为10 而SurvivorRatio的比例为2那么eden空间的大小为10/(2+1+1)*2=5。
- -XX:NewRatio，可以设置老年代和新生代的比例。
- 设置的参数一览表
![参数一览表](https://github.com/myismyself/book_tip_jvm/blob/master/param_all_jvm.jpg)

## 第三章：垃圾回收器和内存分配策略
### 一、垃圾收集算法
#### 1.引用计算算法
-    给对象添加一个计数器，当一个地方引用他就+1，当一个地方失去引用就-1，然后时刻当计数器为0就表述对象不能在被用。java中没有使用它来管理内存，主要是不能解决循环引用的问题。
![循环引用](https://github.com/myismyself/book_tip_jvm/blob/master/xunhuanrefen.jpg)
虚拟机并没有因为他们循环引用就不回收他们， 说明虚拟机没有用引用计数算法
#### 2.根搜索算法
-    这个算法的基本思路是通过名为GC roots的对象作为起始点，从这些节点向下开始搜索，搜索所走过的路径成为引用链，当一个对象到gc roots 没有任何引用链，则证明这个对象不可用，被判定为可回收对象。
java中可以作为GC roots对象包括以下几种：①虚拟机栈（栈帧中的本地变量表）中的引用对象  ②方法区中类静态属性引用的对象③方法区中常量引用的对象④本地方法栈中JNI(即一般说的Native方法)引用的对象。
- 有关引用的描述分类
![分类描述](https://github.com/myismyself/book_tip_jvm/blob/master/reference_example.png)
引用的实际运用：
1. What——什么是弱引用？
Java中的弱引用具体指的是java.lang.ref.WeakReference<T>类，我们首先来看一下官方文档对它做的说明：
弱引用对象的存在不会阻止它所指向的对象被垃圾回收器回收。弱引用最常见的用途是实现规范映射(canonicalizing mappings，比如哈希表）。
假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后把这个弱可达对象标记为可终结(finalizable)的，这样它随后就会被回收。与此同时或稍后，垃圾收集器会把那些刚清除的弱引用放入创建弱引用对象时所指定的引用队列(Reference Queue)中。
 
实际上，Java中存在四种引用，它们由强到弱依次是：强引用、软引用、弱引用、虚引用。下面我们简单介绍下除弱引用外的其他三种引用：
  ● 强引用（Strong Reference）：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收
  ● 软引用（Soft Reference）：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些
  ● 虚引用（Phantom Reference）：虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。
  ```
 
Why——为什么使用弱引用？
考虑下面的场景：现在有一个Product类代表一种产品，这个类被设计为不可扩展的，而此时我们想要为每个产品增加一个编号。一种解决方案是使用HashMap<Product, Integer>。于是问题来了，如果我们已经不再需要一个Product对象存在于内存中（比如已经卖出了这件产品），假设指向它的引用为productA，我们这时会给productA赋值为null，然而这时productA过去指向的Product对象并不会被回收，因为它显然还被HashMap引用着。所以这种情况下，我们想要真正的回收一个Product对象，仅仅把它的强引用赋值为null是不够的，还要把相应的条目从HashMap中移除。显然“从HashMap中移除不再需要的条目”这个工作我们不想自己完成，我们希望告诉垃圾收集器：在只有HashMap中的key在引用着Product对象的情况下，就可以回收相应Product对象了。显然，根据前面弱引用的定义，使用弱引用能帮助我们达成这个目的。我们只需要用一个指向Product对象的弱引用对象来作为HashMap中的key就可以了。
How——如何使用弱引用？
拿上面介绍的场景举例，我们使用一个指向Product对象的弱引用对象来作为HashMap的key，只需这样定义这个弱引用对象：
  ```
Product productA = new Product(...);
WeakReference<Product> weakProductA = new WeakReference<>(productA)
 
  ```
  
现在，若引用对象weakProductA就指向了Product对象productA。那么我们怎么通过weakProduct获取它所指向的Product对象productA呢？很简单，只需要下面这句代码：

  ```
Product product = weakProductA.get();
  ```
  
实际上，对于这种情况，Java类库为我们提供了WeakHashMap类，使用和这个类，它的键自然就是弱引用对象，无需我们再手动包装原始对象。这样一来，当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。
引用队列
下面我们来简单地介绍下引用队列的概念。实际上，WeakReference类有两个构造函数：

```
//创建一个指向给定对象的弱引用
WeakReference(T referent) 
//创建一个指向给定对象并且登记到给定引用队列的弱引用
WeakReference(T referent, ReferenceQueue<? super T> q)
```

我们可以看到第二个构造方法中提供了一个ReferenceQueue类型的参数，通过提供这个参数，我们便把创建的弱引用对象注册到了一个引用队列上，这样当它被垃圾回收器清除时，就会把它送入这个引用队列中，我们便可以对这些被清除的弱引用对象进行统一管理。
